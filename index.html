<!DOCTYPE html>
<html>
<head>
    <title>UMAP Conversation Analysis</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .control-group label {
            font-weight: 500;
            color: #444;
            font-size: 14px;
        }
        select, input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background-color: white;
            width: 100%;
            max-width: 300px;
        }
        select:hover, input:hover {
            border-color: #aaa;
        }
        select:focus, input:focus {
            border-color: #666;
            outline: none;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
        }
        .search-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #search-input {
            width: 100%;
        }
        .search-info {
            font-size: 12px;
            color: #666;
        }
        .scatter-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
        }
        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            grid-column: 1 / -1;
        }
        optgroup {
            font-weight: 600;
            color: #666;
        }
        option {
            font-weight: normal;
            color: #333;
            padding: 4px;
        }
        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .legend {
            font-size: 12px;
        }
        .legend-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stats {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
        }
        .point {
            transition: all 0.3s ease;
        }
        .point.dimmed {
            opacity: 0.1;
        }
        .point.highlighted {
            opacity: 1;
            stroke: #000;
            stroke-width: 2px;
        }
        .brush {
            fill: #69b3a2;
            opacity: 0.2;
        }
        .heatmap-cell {
            stroke: #fff;
            stroke-width: 1px;
        }
        .heatmap-label {
            font-size: 12px;
        }
        #heatmap, #detailed-heatmap {
            margin-top: 40px;
        }
        .heatmap-title {
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
        }
        .visualization-section {
            margin: 40px 0;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .visualization-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        #visualization {
            margin-bottom: 40px;
        }
        #heatmap {
            margin: 40px 0;
        }
        #correlation-scatter {
            margin-top: 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>UMAP Conversation Analysis</h1>
        
        <div class="controls">
            <div class="section-title">Visualization Controls</div>
            
            <div class="control-group">
                <label for="color-by">Color by:</label>
                <select id="color-by">
                    <optgroup label="Categorical">
                        <option value="cluster">HDBSCAN Cluster</option>
                        <option value="facilitator_name">Facilitator</option>
                        <option value="coll_title">Group/Collection</option>
                    </optgroup>
                    <optgroup label="Numeric">
                        <option value="cluster_probability">Cluster Probability</option>
                        <option value="num_observed_speakers">Number of Speakers</option>
                        <option value="speaking_time_gini_coefficient">Speaking Time Gini</option>
                        <option value="turn_sequence_entropy">Turn Sequence Entropy</option>
                        <option value="substantive_responsivity_entropy">Substantive Responsivity</option>
                    </optgroup>
                </select>
            </div>
            
            <div class="control-group">
                <label for="group-filter">Filter by Group:</label>
                <select id="group-filter">
                    <option value="all">All Groups</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="collection-filter">Filter by Collection:</label>
                <select id="collection-filter">
                    <option value="all">All Collections</option>
                </select>
            </div>
            
            <div class="search-container">
                <label for="search-input">Search:</label>
                <input type="text" id="search-input" placeholder="Search facilitator or collection...">
                <span class="search-info"></span>
            </div>
        </div>

        <div class="visualization-section">
            <div class="visualization-title">UMAP Projection</div>
        <div id="visualization"></div>
        </div>

        <div class="visualization-section">
            <div class="visualization-title">Cluster Feature Distribution</div>
            <div id="feature-heatmap"></div>
        </div>

        <div class="visualization-section">
            <div class="visualization-title">Cluster Distribution Heatmap</div>
            <div class="control-group" style="max-width: 300px; margin-bottom: 20px;">
                <label for="heatmap-view">View:</label>
                <select id="heatmap-view">
                    <option value="collections">Collections (Grouped)</option>
                    <option value="detailed">Collections (Detailed)</option>
                    <option value="facilitators">Facilitators (2+ conversations)</option>
                </select>
            </div>
            <div id="heatmap"></div>
        </div>
        
        <div class="visualization-section">
            <div class="visualization-title">Feature Correlation Analysis</div>
            <div class="scatter-controls">
                <div class="section-title">Scatter Plot Controls</div>
                
                <div class="control-group">
                    <label for="scatter-x">X-Axis:</label>
                    <select id="scatter-x">
                        <optgroup label="Conversation Metrics">
                            <option value="total_turns_in_conversation">Total Turns</option>
                            <option value="total_speaking_time_seconds">Speaking Time (seconds)</option>
                            <option value="num_observed_speakers">Number of Speakers</option>
                            <option value="num_turns_in_conversation">Number of Turns</option>
                            <option value="num_turns_facilitator">Facilitator Turns</option>
                        </optgroup>
                        <optgroup label="Facilitator Metrics">
                            <option value="facilitator_speaking_percentage">Facilitator Speaking %</option>
                            <option value="facilitator_turns_percentage">Facilitator Turns %</option>
                            <option value="num_turns_facilitator">Facilitator Turn Count</option>
                        </optgroup>
                        <optgroup label="Distribution Metrics">
                            <option value="speaking_time_gini_coefficient">Speaking Time Gini</option>
                            <option value="turn_distribution_gini_coefficient">Turn Distribution Gini</option>
                            <option value="non_facilitator_speaking_gini_coefficient">Non-Facilitator Speaking Gini</option>
                            <option value="non_facilitator_turn_gini_coefficient">Non-Facilitator Turn Gini</option>
                            <option value="gini_subst_responded_rate_nonself">Substantive Response Rate Gini (Non-self)</option>
                            <option value="gini_subst_responded_rate_nonself_nonfac">Substantive Response Rate Gini (Non-self, Non-fac)</option>
                            <option value="gini_subst_responded_rate_nonself_exclfac">Substantive Response Rate Gini (Non-self, Excl-fac)</option>
                            <option value="gini_subst_responded_rate_nonself_nonfac_exclfac">Substantive Response Rate Gini (Non-self, Non-fac, Excl-fac)</option>
                        </optgroup>
                        <optgroup label="Entropy Metrics">
                            <option value="turn_sequence_entropy">Turn Sequence Entropy</option>
                            <option value="substantive_responsivity_entropy">Substantive Responsivity</option>
                        </optgroup>
                        <optgroup label="Response Rates">
                            <option value="avg_subst_responded_rate">Average Substantive Response Rate</option>
                            <option value="avg_mech_responded_rate">Average Mechanical Response Rate</option>
                            <option value="avg_subst_responded_rate_nonself">Substantive Response Rate (Non-self)</option>
                            <option value="avg_subst_responded_rate_nonself_nonfac">Substantive Response Rate (Non-self, Non-fac)</option>
                            <option value="avg_subst_responded_rate_nonself_exclfac">Substantive Response Rate (Non-self, Excl-fac)</option>
                            <option value="avg_subst_responded_rate_nonself_nonfac_exclfac">Substantive Response Rate (Non-self, Non-fac, Excl-fac)</option>
                        </optgroup>
                        <optgroup label="Clustering">
                            <option value="cluster_probability">Cluster Probability</option>
                        </optgroup>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="scatter-y">Y-Axis:</label>
                    <select id="scatter-y">
                        <optgroup label="Conversation Metrics">
                            <option value="total_turns_in_conversation">Total Turns</option>
                            <option value="total_speaking_time_seconds">Speaking Time (seconds)</option>
                            <option value="num_observed_speakers">Number of Speakers</option>
                            <option value="num_turns_in_conversation">Number of Turns</option>
                            <option value="num_turns_facilitator">Facilitator Turns</option>
                        </optgroup>
                        <optgroup label="Facilitator Metrics">
                            <option value="facilitator_speaking_percentage">Facilitator Speaking %</option>
                            <option value="facilitator_turns_percentage">Facilitator Turns %</option>
                            <option value="num_turns_facilitator">Facilitator Turn Count</option>
                        </optgroup>
                        <optgroup label="Distribution Metrics">
                            <option value="speaking_time_gini_coefficient">Speaking Time Gini</option>
                            <option value="turn_distribution_gini_coefficient">Turn Distribution Gini</option>
                            <option value="non_facilitator_speaking_gini_coefficient">Non-Facilitator Speaking Gini</option>
                            <option value="non_facilitator_turn_gini_coefficient">Non-Facilitator Turn Gini</option>
                            <option value="gini_subst_responded_rate_nonself">Substantive Response Rate Gini (Non-self)</option>
                            <option value="gini_subst_responded_rate_nonself_nonfac">Substantive Response Rate Gini (Non-self, Non-fac)</option>
                            <option value="gini_subst_responded_rate_nonself_exclfac">Substantive Response Rate Gini (Non-self, Excl-fac)</option>
                            <option value="gini_subst_responded_rate_nonself_nonfac_exclfac">Substantive Response Rate Gini (Non-self, Non-fac, Excl-fac)</option>
                        </optgroup>
                        <optgroup label="Entropy Metrics">
                            <option value="turn_sequence_entropy">Turn Sequence Entropy</option>
                            <option value="substantive_responsivity_entropy">Substantive Responsivity</option>
                        </optgroup>
                        <optgroup label="Response Rates">
                            <option value="avg_subst_responded_rate">Average Substantive Response Rate</option>
                            <option value="avg_mech_responded_rate">Average Mechanical Response Rate</option>
                            <option value="avg_subst_responded_rate_nonself">Substantive Response Rate (Non-self)</option>
                            <option value="avg_subst_responded_rate_nonself_nonfac">Substantive Response Rate (Non-self, Non-fac)</option>
                            <option value="avg_subst_responded_rate_nonself_exclfac">Substantive Response Rate (Non-self, Excl-fac)</option>
                            <option value="avg_subst_responded_rate_nonself_nonfac_exclfac">Substantive Response Rate (Non-self, Non-fac, Excl-fac)</option>
                        </optgroup>
                        <optgroup label="Clustering">
                            <option value="cluster_probability">Cluster Probability</option>
                        </optgroup>
                    </select>
                </div>

                <div class="control-group">
                    <label for="scatter-color">Color by:</label>
                    <select id="scatter-color">
                        <optgroup label="Categorical">
                            <option value="cluster">HDBSCAN Cluster</option>
                            <option value="facilitator_name">Facilitator</option>
                            <option value="coll_title">Group/Collection</option>
                        </optgroup>
                        <optgroup label="Numeric">
                            <option value="cluster_probability">Cluster Probability</option>
                            <option value="num_observed_speakers">Number of Speakers</option>
                            <option value="speaking_time_gini_coefficient">Speaking Time Gini</option>
                            <option value="turn_sequence_entropy">Turn Sequence Entropy</option>
                            <option value="substantive_responsivity_entropy">Substantive Responsivity</option>
                        </optgroup>
                    </select>
                </div>
            </div>
            <div id="correlation-scatter"></div>
        <div class="stats" id="stats"></div>
        </div>
    </div>

    <script>
        // Load the data
        d3.json('features+umap+clusters (2).json').then(function(data) {
            // Set up the dimensions
            const width = 1000;
            const height = 600;
            const margin = { top: 40, right: 160, bottom: 40, left: 60 };
            const defaultPointSize = 6;
            const defaultOpacity = 0.8;

            // Populate filter dropdowns
            const groups = [...new Set(data.map(d => d.group))].sort();
            const collections = [...new Set(data.map(d => d.coll_title))].sort();
            
            d3.select("#group-filter")
                .selectAll("option:not(:first-child)")
                .data(groups)
                .enter()
                .append("option")
                .attr("value", d => d)
                .text(d => d);
                
            d3.select("#collection-filter")
                .selectAll("option:not(:first-child)")
                .data(collections)
                .enter()
                .append("option")
                .attr("value", d => d)
                .text(d => d);

            // Function to filter data based on selections
            function getFilteredData() {
                const selectedGroup = d3.select("#group-filter").node().value;
                const selectedCollection = d3.select("#collection-filter").node().value;
                
                return data.filter(d => {
                    const groupMatch = selectedGroup === "all" || d.group === selectedGroup;
                    const collectionMatch = selectedCollection === "all" || d.coll_title === selectedCollection;
                    return groupMatch && collectionMatch;
                });
            }

            // Create the SVG container
            const svg = d3.select("#visualization")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // Create tooltip
            const tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip");

            // Search functionality
            function updateSearch(searchTerm) {
                if (!searchTerm) {
                    // Reset all points
                    svg.selectAll(".point")
                        .classed("dimmed", false)
                        .classed("highlighted", false);
                    d3.select(".search-info").text("");
                    return;
                }

                const searchLower = searchTerm.toLowerCase();
                const points = svg.selectAll(".point");
                let matchCount = 0;

                points.each(function(d) {
                    const facilitator = (d.facilitator_name || "").toLowerCase();
                    const collection = (d.coll_title || "").toLowerCase();
                    const isMatch = facilitator.includes(searchLower) || collection.includes(searchLower);
                    
                    d3.select(this)
                        .classed("dimmed", !isMatch)
                        .classed("highlighted", isMatch);

                    if (isMatch) matchCount++;
                });

                d3.select(".search-info").text(`${matchCount} matches found`);
            }

            // Add search event listener
            d3.select("#search-input").on("input", function() {
                updateSearch(this.value);
            });

            function createHeatmap() {
                // Clear previous heatmap
                d3.select("#heatmap").selectAll("*").remove();

                const heatmapType = d3.select("#heatmap-view").node().value;
                const filteredData = getFilteredData();
                
                let yAxisData = [];
                let counts = {};
                let title = "";
                
                // Prepare data based on selected view
                if (heatmapType === "collections") {
                    // Use the group feature directly
                    yAxisData = [...new Set(filteredData.map(d => d.group))].sort();
                    filteredData.forEach(d => {
                        if (!counts[d.group]) counts[d.group] = {};
                        counts[d.group][d.cluster] = (counts[d.group][d.cluster] || 0) + 1;
                    });
                    title = "Cluster Distribution by Group";
                }
                else if (heatmapType === "detailed") {
                    // Filter for Fora collections and count conversations per collection
                    const foraData = filteredData.filter(d => 
                        d.coll_title !== "Frontline pilot: Summer 2024" && 
                        d.coll_title !== "Beyond-the-Ice"
                    );
                    
                    // Count conversations per collection
                    const collectionCounts = {};
                    foraData.forEach(d => {
                        collectionCounts[d.coll_title] = (collectionCounts[d.coll_title] || 0) + 1;
                    });
                    
                    // Filter for collections with 3 or more conversations
                    const validCollections = Object.entries(collectionCounts)
                        .filter(([_, count]) => count >= 3)
                        .map(([name, _]) => name);
                    
                    yAxisData = validCollections.sort();
                    
                    // Create counts only for valid collections
                    foraData.forEach(d => {
                        if (validCollections.includes(d.coll_title)) {
                            if (!counts[d.coll_title]) counts[d.coll_title] = {};
                            counts[d.coll_title][d.cluster] = (counts[d.coll_title][d.cluster] || 0) + 1;
                        }
                    });
                    title = "Detailed Cluster Distribution within Fora (3+ conversations)";
                }
                else if (heatmapType === "facilitators") {
                    // Count conversations per facilitator
                    const facilitatorCounts = {};
                    filteredData.forEach(d => {
                        facilitatorCounts[d.facilitator_name] = (facilitatorCounts[d.facilitator_name] || 0) + 1;
                    });
                    
                    // Filter for facilitators with more than one conversation
                    yAxisData = Object.entries(facilitatorCounts)
                        .filter(([_, count]) => count > 1)
                        .map(([name, _]) => name)
                        .sort();
                    
                    filteredData.forEach(d => {
                        if (yAxisData.includes(d.facilitator_name)) {
                            if (!counts[d.facilitator_name]) counts[d.facilitator_name] = {};
                            counts[d.facilitator_name][d.cluster] = (counts[d.facilitator_name][d.cluster] || 0) + 1;
                        }
                    });
                    title = "Cluster Distribution by Facilitator (2+ conversations)";
                }

                // Get unique clusters
                const clusters = [...new Set(filteredData.map(d => d.cluster))].sort((a, b) => a - b);

                // Set up dimensions
                const cellWidth = 80;
                const cellHeight = 40;
                const margin = { 
                    top: 60, 
                    right: 60, 
                    bottom: 40, 
                    left: heatmapType === "detailed" ? 300 : 200 
                };
                const width = clusters.length * cellWidth + margin.left + margin.right;
                const height = yAxisData.length * cellHeight + margin.top + margin.bottom;

                // Create SVG
                const svg = d3.select("#heatmap")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

                // Add background rectangle
                svg.append("rect")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("fill", "#f8f9fa");

                // Create scales
                const x = d3.scaleBand()
                    .range([0, clusters.length * cellWidth])
                    .domain(clusters)
                    .padding(0.05);

                const y = d3.scaleBand()
                    .range([0, yAxisData.length * cellHeight])
                    .domain(yAxisData)
                    .padding(0.05);

                // Create color scale
                const maxCount = d3.max(yAxisData, item => 
                    d3.max(clusters, cluster => (counts[item]?.[cluster] || 0)));
                
                const colorScale = d3.scaleSequential()
                    .interpolator(d3.interpolateYlOrRd)
                    .domain([0, maxCount]);

                // Add cells
                yAxisData.forEach((item, i) => {
                    clusters.forEach((cluster, j) => {
                        const count = counts[item]?.[cluster] || 0;
                        
                        // Add cell rectangle
                        svg.append("rect")
                            .attr("x", margin.left + j * cellWidth)
                            .attr("y", margin.top + i * cellHeight)
                            .attr("width", cellWidth)
                            .attr("height", cellHeight)
                            .attr("class", "heatmap-cell")
                            .style("fill", colorScale(count))
                            .on("mouseover", function(event) {
                                tooltip.style("opacity", 1)
                                    .html(`
                                        <strong>${item}</strong><br>
                                        <strong>Cluster ${cluster === -1 ? '(Noise)' : cluster}:</strong> ${count} conversations
                                    `)
                                    .style("left", (event.pageX + 10) + "px")
                                    .style("top", (event.pageY - 10) + "px");
                            })
                            .on("mouseout", function() {
                                tooltip.style("opacity", 0);
                            });

                        // Add count text if greater than 0
                        if (count > 0) {
                            svg.append("text")
                                .attr("x", margin.left + j * cellWidth + cellWidth/2)
                                .attr("y", margin.top + i * cellHeight + cellHeight/2)
                                .attr("text-anchor", "middle")
                                .attr("dominant-baseline", "middle")
                                .style("font-size", "11px")
                                .style("font-weight", "500")
                                .style("fill", count > maxCount/2 ? "white" : "black")
                                .text(count);
                        }
                    });

                    // Add row labels
                    svg.append("text")
                        .attr("x", margin.left - 10)
                        .attr("y", margin.top + i * cellHeight + cellHeight/2)
                        .attr("text-anchor", "end")
                        .attr("dominant-baseline", "middle")
                        .style("font-size", "12px")
                        .style("font-weight", "600")
                        .text(item);

                    // Add conversation counts for facilitators view
                    if (heatmapType === "facilitators") {
                        const totalCount = clusters.reduce((sum, cluster) => sum + (counts[item]?.[cluster] || 0), 0);
                        svg.append("text")
                            .attr("x", margin.left + clusters.length * cellWidth + 10)
                            .attr("y", margin.top + i * cellHeight + cellHeight/2)
                            .attr("dominant-baseline", "middle")
                            .style("font-size", "12px")
                            .text(`(${totalCount} convs)`);
                    }
                });

                // Add cluster labels
                clusters.forEach((cluster, i) => {
                    svg.append("text")
                        .attr("x", margin.left + i * cellWidth + cellWidth/2)
                        .attr("y", margin.top - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .style("font-weight", "600")
                        .text(cluster === -1 ? "Noise" : cluster);
                });

                // Add title
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", margin.top / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .style("font-weight", "bold")
                    .text(title);
            }

            function updateVisualization() {
                // Clear previous visualization
                svg.selectAll("*").remove();

                // Get current control values and filtered data
                const selectedFeature = d3.select("#color-by").node().value;
                const filteredData = getFilteredData();

                // Create scales for x and y axes
                const xScale = d3.scaleLinear()
                    .domain(d3.extent(filteredData, d => d.d0))
                    .range([margin.left, width - margin.right])
                    .nice();

                const yScale = d3.scaleLinear()
                    .domain(d3.extent(filteredData, d => d.d1))
                    .range([height - margin.bottom, margin.top])
                    .nice();

                // Determine if the selected feature is categorical
                const categoricalFeatures = ['cluster', 'facilitator_name', 'coll_title'];
                const isCategorical = categoricalFeatures.includes(selectedFeature);

                // Create appropriate color scale
                let colorScale;
                if (selectedFeature === 'cluster') {
                    const uniqueClusters = [...new Set(filteredData.map(d => d.cluster))].sort((a, b) => a - b);
                    colorScale = d3.scaleOrdinal()
                        .domain(uniqueClusters)
                        .range(uniqueClusters.map(cluster => 
                            cluster === -1 ? '#808080' : d3.schemeTableau10[cluster % 10]
                        ));
                } else if (isCategorical) {
                    const uniqueValues = [...new Set(filteredData.map(d => d[selectedFeature]))];
                    colorScale = d3.scaleOrdinal()
                        .domain(uniqueValues)
                        .range(d3.schemeTableau10);
                } else {
                    colorScale = d3.scaleSequential()
                        .domain(d3.extent(filteredData, d => d[selectedFeature]))
                        .interpolator(d3.interpolateViridis);
                }

                // Add axes
                const xAxis = d3.axisBottom(xScale);
                const yAxis = d3.axisLeft(yScale);

                svg.append("g")
                    .attr("transform", `translate(0,${height - margin.bottom})`)
                    .call(xAxis);

                svg.append("g")
                    .attr("transform", `translate(${margin.left},0)`)
                    .call(yAxis);

                // Add axis labels
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height - 5)
                    .attr("text-anchor", "middle")
                    .text("UMAP Dimension 1");

                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -height / 2)
                    .attr("y", 15)
                    .attr("text-anchor", "middle")
                    .text("UMAP Dimension 2");

                // Add points
                svg.selectAll("circle")
                    .data(filteredData)
                    .enter()
                    .append("circle")
                    .attr("class", "point")
                    .attr("cx", d => xScale(d.d0))
                    .attr("cy", d => yScale(d.d1))
                    .attr("r", defaultPointSize)
                    .attr("fill", d => colorScale(d[selectedFeature]))
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1)
                    .attr("opacity", defaultOpacity)
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .attr("r", defaultPointSize * 1.5)
                            .attr("stroke-width", 2);
                        
                        // Safely format values with null/undefined checks
                        const formatValue = (value) => {
                            if (value === undefined || value === null) return 'N/A';
                            return isCategorical ? value : Number(value).toFixed(3);
                        };

                        const clusterValue = d.cluster === undefined ? 'N/A' : 
                                           d.cluster === -1 ? 'Noise' : d.cluster;
                        const probabilityValue = d.cluster_probability === undefined ? 'N/A' : 
                                               Number(d.cluster_probability).toFixed(3);
                        
                        let tooltipContent = `
                            <strong>Conversation ID:</strong> ${d.conv_id || 'N/A'}<br>
                            <strong>Cluster:</strong> ${clusterValue}<br>
                            <strong>Cluster Probability:</strong> ${probabilityValue}<br>
                            <strong>Facilitator:</strong> ${d.facilitator_name || 'N/A'}<br>
                            <strong>Collection:</strong> ${d.coll_title || 'N/A'}<br>
                            <strong>${selectedFeature}:</strong> ${formatValue(d[selectedFeature])}
                        `;
                        
                        tooltip.style("opacity", 1)
                            .html(tooltipContent)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .attr("r", defaultPointSize)
                            .attr("stroke-width", 1);
                        tooltip.style("opacity", 0);
                    });

                // Add legend
                if (isCategorical) {
                    const legendSpacing = 20;
                    const legendRectSize = 15;
                    let uniqueValues;
                    
                    if (selectedFeature === 'cluster') {
                        uniqueValues = [...new Set(filteredData.map(d => d.cluster))]
                            .sort((a, b) => a - b)
                            .map(cluster => cluster === -1 ? 'Noise' : `Cluster ${cluster}`);
                    } else {
                        uniqueValues = [...new Set(filteredData.map(d => d[selectedFeature]))];
                    }
                    
                    const legend = svg.append("g")
                        .attr("class", "legend")
                        .attr("transform", `translate(${width - margin.right + 20}, ${margin.top})`);

                    legend.append("text")
                        .attr("class", "legend-title")
                        .attr("x", 0)
                        .attr("y", -10)
                        .text(selectedFeature.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));

                    const legendItems = legend.selectAll(".legend-item")
                        .data(uniqueValues)
                        .enter()
                        .append("g")
                        .attr("class", "legend-item")
                        .attr("transform", (d, i) => `translate(0, ${i * legendSpacing})`);

                    legendItems.append("rect")
                        .attr("width", legendRectSize)
                        .attr("height", legendRectSize)
                        .style("fill", d => {
                            if (selectedFeature === 'cluster') {
                                const cluster = d === 'Noise' ? -1 : parseInt(d.split(' ')[1]);
                                return colorScale(cluster);
                            }
                            return colorScale(d);
                        })
                        .style("opacity", d => {
                            if (selectedFeature === 'cluster') {
                                return d === 'Noise' ? 0.5 : 1;
                            }
                            return 1;
                        })
                        .style("cursor", "pointer")
                        .on("mouseover", function(event, d) {
                            // Get the value to match against
                            const matchValue = selectedFeature === 'cluster' ? 
                                (d === 'Noise' ? -1 : parseInt(d.split(' ')[1])) : d;
                            
                            // Update opacity of points
                            svg.selectAll("circle")
                                .style("opacity", point => 
                                    point[selectedFeature] === matchValue ? 1 : 0.1);
                            
                            // Highlight the legend item
                            d3.select(this).style("stroke", "#000").style("stroke-width", 2);
                        })
                        .on("mouseout", function() {
                            // Reset point opacity
                            svg.selectAll("circle")
                                .style("opacity", defaultOpacity);
                            
                            // Reset legend item
                            d3.select(this).style("stroke", "none");
                        });

                    legendItems.append("text")
                        .attr("x", legendRectSize + 5)
                        .attr("y", legendRectSize - 3)
                        .text(d => d)
                        .style("cursor", "pointer")
                        .on("mouseover", function(event, d) {
                            // Get the value to match against
                            const matchValue = selectedFeature === 'cluster' ? 
                                (d === 'Noise' ? -1 : parseInt(d.split(' ')[1])) : d;
                            
                            // Update opacity of points
                            svg.selectAll("circle")
                                .style("opacity", point => 
                                    point[selectedFeature] === matchValue ? 1 : 0.1);
                            
                            // Highlight the corresponding rect
                            d3.select(this.parentNode).select("rect")
                                .style("stroke", "#000")
                                .style("stroke-width", 2);
                        })
                        .on("mouseout", function() {
                            // Reset point opacity
                            svg.selectAll("circle")
                                .style("opacity", defaultOpacity);
                            
                            // Reset the corresponding rect
                            d3.select(this.parentNode).select("rect")
                                .style("stroke", "none");
                        });
                } else {
                    const legendWidth = 20;
                    const legendHeight = 200;
                    
                    const legendScale = d3.scaleLinear()
                        .domain(colorScale.domain())
                        .range([legendHeight, 0]);

                    const legend = svg.append("g")
                        .attr("class", "legend")
                        .attr("transform", `translate(${width - margin.right + 20}, ${margin.top})`);

                    legend.append("text")
                        .attr("class", "legend-title")
                        .attr("x", 0)
                        .attr("y", -10)
                        .text(selectedFeature.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));

                    const defs = legend.append("defs");
                    const linearGradient = defs.append("linearGradient")
                        .attr("id", "linear-gradient")
                        .attr("x1", "0%")
                        .attr("y1", "100%")
                        .attr("x2", "0%")
                        .attr("y2", "0%");

                    linearGradient.selectAll("stop")
                        .data(d3.range(0, 1.1, 0.1))
                        .enter()
                        .append("stop")
                        .attr("offset", d => d * 100 + "%")
                        .attr("stop-color", d => colorScale(d3.scaleLinear().domain([0, 1]).range(colorScale.domain())(d)));

                    legend.append("rect")
                        .attr("width", legendWidth)
                        .attr("height", legendHeight)
                        .style("fill", "url(#linear-gradient)");

                    const legendAxis = d3.axisRight(legendScale)
                        .ticks(5);

                    legend.append("g")
                        .attr("transform", `translate(${legendWidth}, 0)`)
                        .call(legendAxis);
                }

                // Update stats with filteredData parameter
                updateStats(selectedFeature, filteredData);

                // Reapply search if there's an active search term
                const searchTerm = d3.select("#search-input").node().value;
                if (searchTerm) {
                    updateSearch(searchTerm);
                }

                // Update heatmap
                createHeatmap();
            }

            function updateStats(selectedFeature, filteredData) {
                const statsDiv = d3.select("#stats");
                const categoricalFeatures = ['cluster', 'facilitator_name', 'coll_title'];
                const isCategorical = categoricalFeatures.includes(selectedFeature);

                if (isCategorical) {
                    const counts = d3.rollup(filteredData, v => v.length, d => d[selectedFeature]);
                    const statsHtml = `
                        <strong>${selectedFeature.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} Distribution:</strong><br>
                        ${Array.from(counts.entries())
                            .sort((a, b) => b[1] - a[1])
                            .map(([key, value]) => `${key}: ${value} points`)
                            .join('<br>')}
                    `;
                    statsDiv.html(statsHtml);
                } else {
                    const stats = {
                        min: d3.min(filteredData, d => d[selectedFeature]),
                        max: d3.max(filteredData, d => d[selectedFeature]),
                        mean: d3.mean(filteredData, d => d[selectedFeature]),
                        median: d3.median(filteredData, d => d[selectedFeature])
                    };
                    statsDiv.html(`
                        <strong>${selectedFeature.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} Statistics:</strong><br>
                        Min: ${stats.min.toFixed(3)}<br>
                        Max: ${stats.max.toFixed(3)}<br>
                        Mean: ${stats.mean.toFixed(3)}<br>
                        Median: ${stats.median.toFixed(3)}
                    `);
                }
            }

            function createCorrelationScatter() {
                // Clear previous scatter plot
                d3.select("#correlation-scatter").selectAll("*").remove();

                // Get selected features and filtered data
                const xFeature = d3.select("#scatter-x").node().value;
                const yFeature = d3.select("#scatter-y").node().value;
                const colorFeature = d3.select("#scatter-color").node().value;
                const filteredData = getFilteredData();

                // Set up dimensions
                const scatterWidth = 800;
                const scatterHeight = 400;
                const scatterMargin = { top: 40, right: 160, bottom: 60, left: 60 };

                // Create SVG
                const scatterSvg = d3.select("#correlation-scatter")
                    .append("svg")
                    .attr("width", scatterWidth + scatterMargin.left + scatterMargin.right)
                    .attr("height", scatterHeight + scatterMargin.top + scatterMargin.bottom)
                    .append("g")
                    .attr("transform", `translate(${scatterMargin.left},${scatterMargin.top})`);

                // Create scales
                const xScale = d3.scaleLinear()
                    .domain(d3.extent(filteredData, d => d[xFeature]))
                    .range([0, scatterWidth])
                    .nice();

                const yScale = d3.scaleLinear()
                    .domain(d3.extent(filteredData, d => d[yFeature]))
                    .range([scatterHeight, 0])
                    .nice();

                // Determine if the selected color feature is categorical
                const categoricalFeatures = ['cluster', 'facilitator_name', 'coll_title'];
                const isCategorical = categoricalFeatures.includes(colorFeature);

                // Create appropriate color scale
                let colorScale;
                if (colorFeature === 'cluster') {
                    const uniqueClusters = [...new Set(filteredData.map(d => d[colorFeature]))].sort((a, b) => a - b);
                    colorScale = d3.scaleOrdinal()
                        .domain(uniqueClusters)
                        .range(uniqueClusters.map(cluster => 
                            cluster === -1 ? '#808080' : d3.schemeTableau10[cluster % 10]
                        ));
                } else if (isCategorical) {
                    const uniqueValues = [...new Set(filteredData.map(d => d[colorFeature]))];
                    colorScale = d3.scaleOrdinal()
                        .domain(uniqueValues)
                        .range(d3.schemeTableau10);
                } else {
                    colorScale = d3.scaleSequential()
                        .domain(d3.extent(filteredData, d => d[colorFeature]))
                        .interpolator(d3.interpolateViridis);
                }

                // Add axes
                scatterSvg.append("g")
                    .attr("transform", `translate(0,${scatterHeight})`)
                    .call(d3.axisBottom(xScale));

                scatterSvg.append("g")
                    .call(d3.axisLeft(yScale));

                // Add axis labels
                scatterSvg.append("text")
                    .attr("x", scatterWidth / 2)
                    .attr("y", scatterHeight + 40)
                    .attr("text-anchor", "middle")
                    .text(xFeature.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));

                scatterSvg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -scatterHeight / 2)
                    .attr("y", -40)
                    .attr("text-anchor", "middle")
                    .text(yFeature.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));

                // Calculate correlation line
                const xValues = filteredData.map(d => d[xFeature]);
                const yValues = filteredData.map(d => d[yFeature]);
                
                const xMean = d3.mean(xValues);
                const yMean = d3.mean(yValues);
                const xSD = d3.deviation(xValues);
                const ySD = d3.deviation(yValues);
                
                const correlation = d3.sum(filteredData.map((d, i) => 
                    ((d[xFeature] - xMean) / xSD) * ((d[yFeature] - yMean) / ySD)
                )) / (filteredData.length - 1);

                const slope = correlation * (ySD / xSD);
                const intercept = yMean - slope * xMean;

                // Add correlation line
                const line = d3.line()
                    .x(d => xScale(d))
                    .y(d => yScale(slope * d + intercept));

                const xDomain = xScale.domain();
                
                scatterSvg.append("path")
                    .datum(xDomain)
                    .attr("fill", "none")
                    .attr("stroke", "red")
                    .attr("stroke-width", 1.5)
                    .attr("stroke-dasharray", "4,4")
                    .attr("d", line);

                // Add correlation coefficient text
                scatterSvg.append("text")
                    .attr("x", 10)
                    .attr("y", 20)
                    .text(`Correlation: ${correlation.toFixed(3)}`)
                    .style("font-size", "12px");

                // Add points
                scatterSvg.selectAll("circle")
                    .data(filteredData)
                    .enter()
                    .append("circle")
                    .attr("cx", d => xScale(d[xFeature]))
                    .attr("cy", d => yScale(d[yFeature]))
                    .attr("r", 4)
                    .style("fill", d => colorScale(d[colorFeature]))
                    .style("opacity", 0.6)
                    .on("mouseover", function(event, d) {
                        d3.select(this)
                            .attr("r", 6)
                            .style("opacity", 1);
                        
                        tooltip.style("opacity", 1)
                            .html(`
                                <strong>${colorFeature.replace(/_/g, ' ')}:</strong> ${d[colorFeature]}<br>
                                <strong>${xFeature.replace(/_/g, ' ')}:</strong> ${d[xFeature].toFixed(3)}<br>
                                <strong>${yFeature.replace(/_/g, ' ')}:</strong> ${d[yFeature].toFixed(3)}
                            `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .attr("r", 4)
                            .style("opacity", 0.6);
                        tooltip.style("opacity", 0);
                    });

                // Add legend
                if (isCategorical) {
                    const legendSpacing = 20;
                    const legendRectSize = 15;
                    let uniqueValues;
                    
                    if (colorFeature === 'cluster') {
                        uniqueValues = [...new Set(filteredData.map(d => d[colorFeature]))]
                            .sort((a, b) => a - b)
                            .map(cluster => cluster === -1 ? 'Noise' : `Cluster ${cluster}`);
                    } else {
                        uniqueValues = [...new Set(filteredData.map(d => d[colorFeature]))];
                    }
                    
                    const legend = scatterSvg.append("g")
                        .attr("class", "legend")
                        .attr("transform", `translate(${scatterWidth + 20}, 0)`);

                    legend.append("text")
                        .attr("class", "legend-title")
                        .attr("x", 0)
                        .attr("y", -10)
                        .text(colorFeature.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));

                    const legendItems = legend.selectAll(".legend-item")
                        .data(uniqueValues)
                        .enter()
                        .append("g")
                        .attr("class", "legend-item")
                        .attr("transform", (d, i) => `translate(0, ${i * legendSpacing})`);

                    legendItems.append("rect")
                        .attr("width", legendRectSize)
                        .attr("height", legendRectSize)
                        .style("fill", d => {
                            if (colorFeature === 'cluster') {
                                const cluster = d === 'Noise' ? -1 : parseInt(d.split(' ')[1]);
                                return colorScale(cluster);
                            }
                            return colorScale(d);
                        })
                        .style("opacity", d => {
                            if (colorFeature === 'cluster') {
                                return d === 'Noise' ? 0.5 : 1;
                            }
                            return 1;
                        })
                        .style("cursor", "pointer")
                        .on("mouseover", function(event, d) {
                            // Get the value to match against
                            const matchValue = colorFeature === 'cluster' ? 
                                (d === 'Noise' ? -1 : parseInt(d.split(' ')[1])) : d;
                            
                            // Update opacity of points
                            scatterSvg.selectAll("circle")
                                .style("opacity", point => 
                                    point[colorFeature] === matchValue ? 1 : 0.1);
                            
                            // Highlight the legend item
                            d3.select(this).style("stroke", "#000").style("stroke-width", 2);
                        })
                        .on("mouseout", function() {
                            // Reset point opacity
                            scatterSvg.selectAll("circle")
                                .style("opacity", 0.6);
                            
                            // Reset legend item
                            d3.select(this).style("stroke", "none");
                        });

                    legendItems.append("text")
                        .attr("x", legendRectSize + 5)
                        .attr("y", legendRectSize - 3)
                        .text(d => d)
                        .style("cursor", "pointer")
                        .on("mouseover", function(event, d) {
                            // Get the value to match against
                            const matchValue = colorFeature === 'cluster' ? 
                                (d === 'Noise' ? -1 : parseInt(d.split(' ')[1])) : d;
                            
                            // Update opacity of points
                            scatterSvg.selectAll("circle")
                                .style("opacity", point => 
                                    point[colorFeature] === matchValue ? 1 : 0.1);
                            
                            // Highlight the corresponding rect
                            d3.select(this.parentNode).select("rect")
                                .style("stroke", "#000")
                                .style("stroke-width", 2);
                        })
                        .on("mouseout", function() {
                            // Reset point opacity
                            scatterSvg.selectAll("circle")
                                .style("opacity", 0.6);
                            
                            // Reset the corresponding rect
                            d3.select(this.parentNode).select("rect")
                                .style("stroke", "none");
                        });
                } else {
                    const legendWidth = 20;
                    const legendHeight = 200;
                    
                    const legendScale = d3.scaleLinear()
                        .domain(colorScale.domain())
                        .range([legendHeight, 0]);

                    const legend = scatterSvg.append("g")
                        .attr("class", "legend")
                        .attr("transform", `translate(${scatterWidth + 20}, 0)`);

                    legend.append("text")
                        .attr("class", "legend-title")
                        .attr("x", 0)
                        .attr("y", -10)
                        .text(colorFeature.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));

                    const defs = legend.append("defs");
                    const linearGradient = defs.append("linearGradient")
                        .attr("id", "scatter-linear-gradient")
                        .attr("x1", "0%")
                        .attr("y1", "100%")
                        .attr("x2", "0%")
                        .attr("y2", "0%");

                    linearGradient.selectAll("stop")
                        .data(d3.range(0, 1.1, 0.1))
                        .enter()
                        .append("stop")
                        .attr("offset", d => d * 100 + "%")
                        .attr("stop-color", d => colorScale(d3.scaleLinear().domain([0, 1]).range(colorScale.domain())(d)));

                    legend.append("rect")
                        .attr("width", legendWidth)
                        .attr("height", legendHeight)
                        .style("fill", "url(#scatter-linear-gradient)");

                    const legendAxis = d3.axisRight(legendScale)
                        .ticks(5);

                    legend.append("g")
                        .attr("transform", `translate(${legendWidth}, 0)`)
                        .call(legendAxis);
                }
            }

            function createFeatureHeatmap() {
                // Clear previous heatmap
                d3.select("#feature-heatmap").selectAll("*").remove();

                const filteredData = getFilteredData();
                
                // Define features to include
                const features = [
                    {id: 'speaking_time_gini_coefficient', name: 'Speaking Time Gini'},
                    {id: 'turn_distribution_gini_coefficient', name: 'Turn Distribution Gini'},
                    {id: 'non_facilitator_speaking_gini_coefficient', name: 'Non-Facilitator Speaking Gini'},
                    {id: 'non_facilitator_turn_gini_coefficient', name: 'Non-Facilitator Turn Gini'},
                    {id: 'facilitator_speaking_percentage', name: 'Facilitator Speaking %'},
                    {id: 'facilitator_turns_percentage', name: 'Facilitator Turns %'},
                    {id: 'turn_sequence_entropy', name: 'Turn Sequence Entropy'},
                    {id: 'substantive_responsivity_entropy', name: 'Substantive Responsivity'},
                    {id: 'num_observed_speakers', name: 'Number of Speakers'},
                    {id: 'num_turns_in_conversation', name: 'Number of Turns'},
                    {id: 'num_turns_facilitator', name: 'Facilitator Turns'},
                    {id: 'total_turns_in_conversation', name: 'Total Turns'},
                    {id: 'total_speaking_time_seconds', name: 'Speaking Time (s)'},
                    {id: 'avg_subst_responded_rate', name: 'Avg Substantive Response Rate'},
                    {id: 'avg_mech_responded_rate', name: 'Avg Mechanical Response Rate'},
                    {id: 'avg_subst_responded_rate_nonself', name: 'Substantive Response Rate (Non-self)'},
                    {id: 'avg_subst_responded_rate_nonself_nonfac', name: 'Substantive Response Rate (Non-self, Non-fac)'},
                    {id: 'avg_subst_responded_rate_nonself_exclfac', name: 'Substantive Response Rate (Non-self, Excl-fac)'},
                    {id: 'avg_subst_responded_rate_nonself_nonfac_exclfac', name: 'Substantive Response Rate (Non-self, Non-fac, Excl-fac)'},
                    {id: 'gini_subst_responded_rate_nonself', name: 'Substantive Response Rate Gini (Non-self)'},
                    {id: 'gini_subst_responded_rate_nonself_nonfac', name: 'Substantive Response Rate Gini (Non-self, Non-fac)'},
                    {id: 'gini_subst_responded_rate_nonself_exclfac', name: 'Substantive Response Rate Gini (Non-self, Excl-fac)'},
                    {id: 'gini_subst_responded_rate_nonself_nonfac_exclfac', name: 'Substantive Response Rate Gini (Non-self, Non-fac, Excl-fac)'},
                    {id: 'cluster_probability', name: 'Cluster Probability'}
                ];

                // Get unique clusters, including -1 for noise points
                const clusters = [...new Set(filteredData.map(d => d.cluster))]
                    .sort((a, b) => a - b);

                console.log("All clusters found:", clusters);
                if (clusters.length === 0) {
                    console.log("No clusters found in filtered data");
                    return;
                }

                // Calculate averages for each cluster-feature combination
                const averages = {};
                clusters.forEach(cluster => {
                    const clusterData = filteredData.filter(d => d.cluster === cluster);
                    console.log(`Cluster ${cluster} has ${clusterData.length} points`);
                    averages[cluster] = {};
                    features.forEach(feature => {
                        const values = clusterData.map(d => d[feature.id]).filter(v => v !== undefined && v !== null);
                        averages[cluster][feature.id] = values.length > 0 ? d3.mean(values) : null;
                    });
                });

                // Set up dimensions
                const cellWidth = 80;
                const cellHeight = 40;
                const margin = { top: 60, right: 60, bottom: 40, left: 200 };
                const width = clusters.length * cellWidth + margin.left + margin.right;
                const height = features.length * cellHeight + margin.top + margin.bottom;

                // Create SVG
                const svg = d3.select("#feature-heatmap")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

                // Add background rectangle
                svg.append("rect")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("fill", "#f8f9fa");

                // Create color scales for each feature
                const colorScales = {};
                features.forEach(feature => {
                    const values = clusters
                        .map(cluster => averages[cluster][feature.id])
                        .filter(v => v !== null && !isNaN(v));
                    const min = d3.min(values);
                    const max = d3.max(values);
                    console.log(`Feature ${feature.name} range:`, min, max);
                    colorScales[feature.id] = d3.scaleSequential()
                        .domain([min, max])
                        .interpolator(d3.interpolateYlOrRd);
                });

                // Add cells
                features.forEach((feature, i) => {
                    clusters.forEach((cluster, j) => {
                        const value = averages[cluster][feature.id];
                        
                        // Add cell rectangle
                        svg.append("rect")
                            .attr("x", margin.left + j * cellWidth)
                            .attr("y", margin.top + i * cellHeight)
                            .attr("width", cellWidth)
                            .attr("height", cellHeight)
                            .attr("class", "heatmap-cell")
                            .style("fill", value !== null && !isNaN(value) ? colorScales[feature.id](value) : "#eee")
                            .on("mouseover", function(event) {
                                tooltip.style("opacity", 1)
                                    .html(`
                                        <strong>${cluster === -1 ? 'Noise' : cluster}</strong><br>
                                        <strong>${feature.name}:</strong> ${value !== null && !isNaN(value) ? value.toFixed(3) : 'N/A'}<br>
                                        <strong>Cluster size:</strong> ${filteredData.filter(d => d.cluster === cluster).length} conversations
                                    `)
                                    .style("left", (event.pageX + 10) + "px")
                                    .style("top", (event.pageY - 10) + "px");
                            })
                            .on("mouseout", function() {
                                tooltip.style("opacity", 0);
                            });

                        // Only add value text if value exists and is valid
                        if (value !== null && !isNaN(value)) {
                            // Format value based on magnitude
                            let displayValue;
                            if (Math.abs(value) < 0.01) {
                                displayValue = value.toExponential(1);
                            } else if (Math.abs(value) >= 100) {
                                displayValue = value.toFixed(0);
                            } else {
                                displayValue = value.toFixed(2);
                            }

                            // Add value text
                            svg.append("text")
                                .attr("x", margin.left + j * cellWidth + cellWidth/2)
                                .attr("y", margin.top + i * cellHeight + cellHeight/2)
                                .attr("text-anchor", "middle")
                                .attr("dominant-baseline", "middle")
                                .style("font-size", "11px")
                                .style("font-weight", "500")
                                .style("fill", value > d3.mean(clusters.map(c => averages[c][feature.id]).filter(v => v !== null && !isNaN(v))) ? "white" : "black")
                                .text(displayValue);
                        }
                    });

                    // Add feature labels
                    svg.append("text")
                        .attr("x", margin.left - 10)
                        .attr("y", margin.top + i * cellHeight + cellHeight/2)
                        .attr("text-anchor", "end")
                        .attr("dominant-baseline", "middle")
                        .style("font-size", "12px")
                        .style("font-weight", "600")
                        .text(feature.name);
                });

                // Add cluster labels
                clusters.forEach((cluster, i) => {
                    svg.append("text")
                        .attr("x", margin.left + i * cellWidth + cellWidth/2)
                        .attr("y", margin.top - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .style("font-weight", "600")
                        .text(cluster === -1 ? "Noise" : cluster);
                });

                // Add title
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", margin.top / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .style("font-weight", "bold")
                    .text("Average Feature Values by Cluster");
            }

            // Add event listeners for filters
            d3.select("#group-filter").on("change", function() {
                updateVisualization();
                createFeatureHeatmap();
                createHeatmap();
                createCorrelationScatter();
            });

            d3.select("#collection-filter").on("change", function() {
                updateVisualization();
                createFeatureHeatmap();
                createHeatmap();
                createCorrelationScatter();
            });

            // Existing event listeners
            d3.select("#color-by").on("change", updateVisualization);
            d3.select("#heatmap-view").on("change", createHeatmap);
            d3.select("#scatter-x").on("change", createCorrelationScatter);
            d3.select("#scatter-y").on("change", createCorrelationScatter);
            d3.select("#scatter-color").on("change", createCorrelationScatter);
            d3.select("#search-input").on("input", function() {
                updateSearch(this.value);
            });

            // Initial visualization
            updateVisualization();
            createFeatureHeatmap();
            createCorrelationScatter();
        });
    </script>
</body>
</html> 